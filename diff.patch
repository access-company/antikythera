diff --git a/core/async_job/async_job.ex b/core/async_job/async_job.ex
index 5de5aad..f4fc0c8 100644
--- a/core/async_job/async_job.ex
+++ b/core/async_job/async_job.ex
@@ -24,7 +24,6 @@ defmodule AntikytheraCore.AsyncJob do
     remaining_attempts: Attempts,
     retry_interval:     RetryInterval,
     payload:            Croma.Map, # opaque data given and used by gear
-    immediate:          Croma.Boolean,
   ]
 
   @typep option :: Antikythera.AsyncJob.option
@@ -38,9 +37,10 @@ defmodule AntikytheraCore.AsyncJob do
     R.m do
       epool_id                      <- find_executor_pool(gear_name, context_or_epool_id)
       job_id                        <- extract_job_id(options)
+      bypass?                       <- bypass_job_queue?(options)
       {schedule, start_time_millis} <- validate_schedule(now_millis, options)
       job                           <- make_job(gear_name, module, payload, schedule, options)
-      do_register(epool_id, job_id, job, start_time_millis, now_millis)
+      do_register(epool_id, job_id, job, bypass?, start_time_millis, now_millis)
     end
   end
 
@@ -58,6 +58,23 @@ defmodule AntikytheraCore.AsyncJob do
     end
   end
 
+  defunp bypass_job_queue?(options :: v[[option]]) :: R.t(boolean) do
+    case options[:bypass_job_queue] do
+      true ->
+        [:schedule, :attempts, :retry_interval]
+        |> Enum.map(fn disallowed ->
+          if Keyword.has_key?(options, disallowed) do
+            {:error, {:invalid_key_combination, :bypass_job_queue, disallowed}}
+          else
+            {:ok, nil}
+          end
+        end)
+        |> R.sequence()
+        |> R.map(fn _ -> true end)
+      _ -> {:ok, false}
+    end
+  end
+
   defunp validate_schedule(now_millis :: v[MilliSecondsSinceEpoch.t], options :: v[[option]]) :: R.t({Schedule.t, MilliSecondsSinceEpoch.t}) do
     case options[:schedule] do
       nil        -> {:ok, {{:once, Time.from_epoch_milliseconds(now_millis)}, now_millis}}
@@ -92,31 +109,17 @@ defmodule AntikytheraCore.AsyncJob do
       remaining_attempts: attempts,
       retry_interval:     Keyword.get(options, :retry_interval, RetryInterval.default()),
       payload:            payload,
-      immediate:          immediate_job?(options),
     ])
   end
 
-  defunp immediate_job?(options :: v[[option]]) :: boolean do
-    case options[:immediate] do
-      true ->
-        debug_assert(
-          [:schedule, :attempts, :retry_interval]
-          |> Enum.map(fn disallowed -> not Keyword.has_key?(options, disallowed) end)
-          |> Enum.all?(),
-          ":schedule, :attempts and :retry_interval cannot used with :immediate option"
-        )
-        true
-      _ -> false
-    end
-  end
-
   defunp do_register(epool_id          :: v[EPoolId.t],
                      job_id            :: v[Id.t],
                      job               :: v[t],
+                     bypass?           :: v[boolean],
                      start_time_millis :: v[MilliSecondsSinceEpoch.t],
                      now_millis        :: v[MilliSecondsSinceEpoch.t]) :: R.t(Id.t) do
-    if job.immediate do
-      run_immediately(epool_id, job_id, job, now_millis)
+    if bypass? do
+      run_immediately_bypassing_job_queue(epool_id, job_id, job, now_millis)
     else
       queue_name = RegName.async_job_queue(epool_id)
       case Queue.add_job(queue_name, job_id, job, start_time_millis, now_millis) do
@@ -126,10 +129,10 @@ defmodule AntikytheraCore.AsyncJob do
     end
   end
 
-  defunp run_immediately(epool_id   :: v[EPoolId.t],
-                         job_id     :: v[Id.t],
-                         job        :: v[t],
-                         now_millis :: v[MilliSecondsSinceEpoch.t]) :: R.t(Id.t) do
+  defunp run_immediately_bypassing_job_queue(epool_id   :: v[EPoolId.t],
+                                             job_id     :: v[Id.t],
+                                             job        :: v[t],
+                                             now_millis :: v[MilliSecondsSinceEpoch.t]) :: R.t(Id.t) do
     pool_name = RegName.async_job_runner_pool(epool_id)
     case PoolSup.checkout_nonblocking(pool_name) do
       nil -> {:error, :no_available_workers}
diff --git a/core/sup_tree_core/executor_pool/async_job_runner.ex b/core/sup_tree_core/executor_pool/async_job_runner.ex
index fa8201e..f6191d0 100644
--- a/core/sup_tree_core/executor_pool/async_job_runner.ex
+++ b/core/sup_tree_core/executor_pool/async_job_runner.ex
@@ -54,7 +54,7 @@ defmodule AntikytheraCore.ExecutorPool.AsyncJobRunner do
     {pid, monitor_ref, timer_ref} = start_monitor(job, metadata, context)
     new_state = %{
       epool_id:    epool_id,
-      queue_name:  queue_name,
+      queue_name:  queue_name, # can be `nil` if the job is executed with `:bypass_job_queue` option
       worker:      pid,
       monitor:     monitor_ref,
       timer:       timer_ref,
@@ -224,7 +224,7 @@ defmodule AntikytheraCore.ExecutorPool.AsyncJobRunner do
   #
   # Public API
   #
-  defun run(pid :: v[pid], queue_name :: v[atom], job_key :: v[JobKey.t], job :: v[AsyncJob.t]) :: :ok do
+  defun run(pid :: v[pid], queue_name :: v[atom | nil], job_key :: v[JobKey.t], job :: v[AsyncJob.t]) :: :ok do
     GenServer.cast(pid, {:run, queue_name, job_key, job})
   end
 end
diff --git a/lib/async_job/async_job.ex b/lib/async_job/async_job.ex
index 05d3048..63d659e 100644
--- a/lib/async_job/async_job.ex
+++ b/lib/async_job/async_job.ex
@@ -150,12 +150,12 @@ defmodule Antikythera.AsyncJob do
   @callback abandon(map, Metadata.t, Context.t) :: any
   @callback inspect_payload(map) :: String.t
 
-  @type option :: {:id            , Id.t           }
-                | {:schedule      , Schedule.t     }
-                | {:max_duration  , MaxDuration.t  }
-                | {:attempts      , Attempts.t     }
-                | {:retry_interval, RetryInterval.t}
-                | {:immediate     , boolean        }
+  @type option :: {:id              , Id.t           }
+                | {:schedule        , Schedule.t     }
+                | {:max_duration    , MaxDuration.t  }
+                | {:attempts        , Attempts.t     }
+                | {:retry_interval  , RetryInterval.t}
+                | {:bypass_job_queue, boolean        }
 
   defmacro __using__(_) do
     gear_name = Mix.Project.config()[:app]
diff --git a/test/core/async_job/queue_test.exs b/test/core/async_job/queue_test.exs
index 43072e5..0ed6466 100644
--- a/test/core/async_job/queue_test.exs
+++ b/test/core/async_job/queue_test.exs
@@ -107,20 +107,20 @@ defmodule AntikytheraCore.AsyncJob.QueueTest do
     end)
 
     [
-      id:             String.duplicate("a", 32),
-      schedule:       {:once, Time.shift_seconds(Time.now(), 1)},
-      schedule:       {:once, Time.shift_days(Time.now(), 49)},
-      schedule:       {:cron, Cron.parse!("* * * * *")},
-      attempts:       1,
-      attempts:       10,
-      max_duration:   1,
-      max_duration:   1_800_000,
-      retry_interval: {0, 2.0},
-      retry_interval: {300_000, 2.0},
-      retry_interval: {10_000, 1.0},
-      retry_interval: {10_000, 5.0},
-      immediate:      true,
-      immediate:      false,
+      id:               String.duplicate("a", 32),
+      schedule:         {:once, Time.shift_seconds(Time.now(), 1)},
+      schedule:         {:once, Time.shift_days(Time.now(), 49)},
+      schedule:         {:cron, Cron.parse!("* * * * *")},
+      attempts:         1,
+      attempts:         10,
+      max_duration:     1,
+      max_duration:     1_800_000,
+      retry_interval:   {0, 2.0},
+      retry_interval:   {300_000, 2.0},
+      retry_interval:   {10_000, 1.0},
+      retry_interval:   {10_000, 5.0},
+      bypass_job_queue: true,
+      bypass_job_queue: false,
     ] |> Enum.each(fn option_pair ->
       AsyncJobHelper.reset_rate_limit_status(@epool_id)
       assert register_job([option_pair]) == :ok
@@ -148,10 +148,10 @@ defmodule AntikytheraCore.AsyncJob.QueueTest do
     end)
   end
 
-  test "register should not add a job with :immediate option to the queue" do
-    assert Queue.fetch_job(@queue_name)    == nil
-    assert register_job([immediate: true]) == :ok
-    assert Queue.fetch_job(@queue_name)    == nil
+  test "register should not add a job with :bypass_job_queue option to the queue" do
+    assert Queue.fetch_job(@queue_name)           == nil
+    assert register_job([bypass_job_queue: true]) == :ok
+    assert Queue.fetch_job(@queue_name)           == nil
   end
 
   test "register => remove_locked" do
